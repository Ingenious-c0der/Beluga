#ifndef TYPES_H
#define TYPES_H


enum class ERROR_TYPES
{
    INVALID_SYNTAX = -1,
    INVALID_ARGUMENTS = -2,
    INVALID_FILE = -3,
    INVALID_FILE_TYPE = -4,
    INVALID_FILE_EXTENSION = -5,
    INVALID_FILE_NAME = -6,
    INVALID_FILE_PATH = -7,
    INVALID_FILE_SIZE = -8,
    MAX_RECURSION_REACHED = -9,
    NON_HALTING = -10,
    INVALID_TRANSITION = -11,
    INVALID_TYPE = -12,
    INVALID_SUBTYPE = -13,
    INVALID_STATE = -14,
    INVALID_DEFINITION = -15,
    UNKNOWN_SYMBOL = -16,
    UNKNOWN_UNKNOWN = -255,
    TAPE_OVERFLOW_ACCESS_LEFT = -256, 
    TAPE_OVERFLOW_ACCESS_RIGHT = -257,
};


//stringify the error types
constexpr const char* stringify(ERROR_TYPES e)
{
    switch (e)
    {
    case ERROR_TYPES::INVALID_SYNTAX: return "INVALID_SYNTAX";
    case ERROR_TYPES::INVALID_ARGUMENTS: return "INVALID_ARGUMENTS";
    case ERROR_TYPES::INVALID_FILE: return "INVALID_FILE";
    case ERROR_TYPES::INVALID_FILE_TYPE: return "INVALID_FILE_TYPE";
    case ERROR_TYPES::INVALID_FILE_EXTENSION: return "INVALID_FILE_EXTENSION";
    case ERROR_TYPES::INVALID_FILE_NAME: return "INVALID_FILE_NAME";
    case ERROR_TYPES::INVALID_FILE_PATH: return "INVALID_FILE_PATH";
    case ERROR_TYPES::INVALID_FILE_SIZE: return "INVALID_FILE_SIZE";
    case ERROR_TYPES::MAX_RECURSION_REACHED: return "MAX_RECURSION_REACHED";
    case ERROR_TYPES::NON_HALTING: return "NON_HALTING";
    case ERROR_TYPES::INVALID_TRANSITION: return "INVALID_TRANSITION";
    case ERROR_TYPES::INVALID_TYPE: return "INVALID_TYPE";
    case ERROR_TYPES::INVALID_SUBTYPE: return "INVALID_SUBTYPE";
    case ERROR_TYPES::INVALID_STATE: return "INVALID_STATE";
    case ERROR_TYPES::INVALID_DEFINITION: return "INVALID_DEFINITION";
    case ERROR_TYPES::UNKNOWN_SYMBOL: return "UNKNOWN_SYMBOL";
    case ERROR_TYPES::UNKNOWN_UNKNOWN: return "UNKNOWN_UNKNOWN";
    case ERROR_TYPES::TAPE_OVERFLOW_ACCESS_LEFT: return "TAPE_OVERFLOW_ACCESS_LEFT";
    case ERROR_TYPES::TAPE_OVERFLOW_ACCESS_RIGHT: return "TAPE_OVERFLOW_ACCESS_RIGHT";
    default: return "UNKNOWN_ERROR";
    }
}




enum class Type
{
    MACHINE,
    LIST,
    SYMBOL,
    SET,
    TUPLE,
    DECISION,
    null,
};


enum class Subtype
{
    TAPE,
    STATE,
    TRANSITION,
    INPUT_SYMBOL,
    TAPE_SYMBOL,
    TRANSITION_DIRECTION_SYMBOL,
    TRANSITION_STATE_SYMBOL,
    TRANSITION_TAPE_SYMBOL,
    BLANK_SYMBOL,
    ACCEPT,
    REJECT,
    UNDEFINED, 
};

#endif